"use strict";

/**
 * Object which contains a bruteforcer instance, timer, and several useful methods for manipulating the
 * bruteforcer, timer, document grid, document buttons, etc.
 */
const sudoku = {

	/** 
	 * class instance of the bruteforcer, which stores a copy of the sudoku made by the user and contains
	 * the bruteforcing algorithm
	 * @type {Bruteforcer}
	 * @type {null} - if bruteforcer has not yet started
	 */
	bruteforcer: null,

	/**
	 * speed of iteration
	 * @type {number}
	 */
	speed: 125,

	/**
	 * ID of the setInterval timer
	 * @type {number}
	 * @type {null} - if bruteforcer has not yet started, is paused, or sudoku is finished
	 */
	timer: null,

	/**
	 * a string representing the sudoku from top-down left to right, with 0 meaning blank
	 * @type {string}
	 */
	code_decimal: "",

	/**
	 * an array of pregenerated sudokus. see randomiseSudoku() for more details. randomly generating sudoku 
	 * puzzles is not currently in the scope of this project.
	 * 
	 * these were generated by qqwing (qqwing.com), and are randomly generated expert difficulty sudokus such
	 * that the total iterations of the algorithm were relatively small <13000.
	 * @type {Array}
	 */
	pregen: [
		"000100400750600200040007009307009002000240000004306000000000093103000000000020007", // 9275
		"000016000950080000087050040008000004200800560000740021000000000001020080462000000", // 12212
		"085900030300010000006005400000000906000100084050060010000000620002003008090820100", // 4080
		"200003000000006013064800000000970000001080970009004800080300001040000060003020080", // 1675
		"900500008020030090400009670070800204068005030003000080000400005082007000000000000", // 11033
		"601080379000000104000000000740010500006034000080700000000003007000600900300907461", // 12936
		"008100400400000000070205000600080210083001000050700380721800000530600000006000000", // 2644
		"800500147001040025000000903000000070040059300300000000950080401003000000480710000", // 8015
		"007200039500081400402900007800400091000050700073109005000500000010004000000000300", // 10022
		"000659000000700023801030007600200830009001700037000000598000000760000000003060000", // 1354
		"304008007000907005070000600028035076960000000005000004003000000546000000890040050", // 8250
		"800170003000000409002080000013704090040210000000000007000000601001023870000000000", // 12197
	],

	/**
	 * @method
	 * initiates a bruteforcer and starts the bruteforcing algorithm.
	 */
	start() {
		const matrix = new Array(9);
		const error_div = document.getElementById("errors");
		this.speed = Number(document.getElementById("speed").value);
		
		// obtain matrix from document
		for (let i=0; i<9; i++) {
			const row = new Array(9);
			for (let j=0; j<9; j++) {
				row[j] = Number(document.getElementById(String(i) + String(j)).value);
			}
			matrix[i] = row;
		}
		// initiate SudokuGrid
		this.bruteforcer = new Bruteforcer(matrix);

		// check for errors. break if there are any errors
		error_div.innerHTML = "";
		const errors = this.bruteforcer.check();
		if (errors.length !== 0) {
			for (let i=0; i<errors.length; i++) {
				error_div.innerHTML += errors[i] + "<br/>";
			}
			this.bruteforcer = null;
			return;
		}

		document.getElementById("skip").disabled = false;
		document.getElementById("next").disabled = true;
		document.getElementById("left-button").innerText = "Reset";
		document.getElementById("right-button").innerText = "Pause";
		// freeze cells and set classnames
		for (let i=0; i<9; i++) {
			for (let j=0; j<9; j++) {
				const cell = document.getElementById(String(i) + String(j));
				cell.disabled = true;
				if (cell.value !== "") {
					cell.className = "fixed";
				} else {
					cell.className = "unfilled";
				}
			}
		}

		this.play();
	},

	/**
	 * @method
	 * plays or resumes the iteration timer, calling this.next at intervals corresponding to this.speed
	 */
	play() {
		document.getElementById("right-button").innerText = "Pause";
		document.getElementById("next").disabled = true;
		clearInterval(this.timer);
		// configure timer:
		// generally, setInterval delay is capped at once per 4ms (250Hz). if speed exceeds this, do
		// multiple iterations per interval. actual speed = number of iterations / delay
		const n_intervals = Math.ceil(this.speed/250);
		const delay = 1000 * Math.ceil(this.speed/250)/this.speed;
		this.timer = setInterval(() => this.next(n_intervals), delay);
	},

	/**
	 * @method
	 * pauses the iteration timer
	 */
	pause() {
		document.getElementById("right-button").innerText = "Resume";
		document.getElementById("next").disabled = false;
		clearInterval(this.timer);
		this.timer = null;
	},

	/**
	 * @method
	 * removes all progress on the bruteforcing of the sudoku, removing the bruteforcer property and
	 * resets to the initial sudoku.
	 */
	reset() {
		document.getElementById("skip").disabled = true;
		document.getElementById("next").disabled = true;
		document.getElementById("right-button").disabled = false;
		document.getElementById("left-button").innerText = "Clear";
		document.getElementById("right-button").innerText = "Start";
		document.getElementById("iter").value = "0";
		document.getElementById("errors").innerHTML = "";
		document.getElementById("success").innerHTML = "";
		clearInterval(this.timer);
		for (let i=0; i<9; i++) {
			for (let j=0; j<9; j++) {
				const cell = document.getElementById(String(i) + String(j));
				if (cell.className === "unfilled" || cell.className === "complete") {
					cell.value = "";
				}
				cell.disabled = false;
				cell.className = "sudoku";
			}
		}
		this.bruteforcer = null;
		this.timer = null;
	},

	/**
	 * @method
	 * removes all user inputs on the sudoku, leaving a blank grid.
	 */
	clear() {
		document.getElementById("errors").innerHTML = "";
		document.getElementById("success").innerHTML = "";
		for (let i=0; i<9; i++) {
			for (let j=0; j<9; j++) {
				document.getElementById(String(i) + String(j)).value = "";
			}
		}
	},

	/**
	 * @method
	 * iterates forward in the bruteforcer, and updates the sudoku in the document with new values.
	 * @param {number} steps - number of bruteforce steps to take.
	 */
	next(steps) {
		for (let n=0; n<steps; n++){
			try {
				const [i, j, value] = this.bruteforcer.nextStep();
				document.getElementById(String(i) + String(j)).value = (value === 0) ? "" : String(value);
			} catch {
				this.finish(this.bruteforcer.status === "success");
				break;
			}
		}
		document.getElementById("iter").value = String(this.bruteforcer.iter);
	},

	/**
	 * @method
	 * declare the sudoku finished, either being a success (turns all numbers filled in by the bruteforcer from red
	 * to green) or a failure (no possible solution, shows the user an error)
	 * @param {boolean} status - either true (success) or false (failure)
	 */
	finish(status) {
		document.getElementById("right-button").innerText = "Pause";
		document.getElementById("next").disabled = true;
		document.getElementById("skip").disabled = true;
		document.getElementById("right-button").disabled = true;
		clearInterval(this.timer);
		this.timer = null;
		if (status) {
			document.getElementById("success").innerHTML = "Sudoku has been solved!";
			for (let i=0; i<9; i++) {
				for (let j=0; j<9; j++) {
					const cell = document.getElementById(String(i) + String(j));
					if (cell.className === "unfilled") {
						cell.className = "complete";
					}
				}
			}
		} else {
			document.getElementById("errors").innerHTML = "Sudoku has no solutions";
		}
	}
};

/**
 * @function
 * function to call when website is loaded.
 */
function setUp() {
	// remove enable javascript message
	const table = document.getElementById("table");
	table.innerHTML = "";
	// fetch a sudoku code from the url, if any
	const params = new URLSearchParams(window.location.search);
	let code = params.get("code");
	if (!code) {
		code = "";
	}
	try {
		sudoku.code_decimal = b64.from(code).padStart(81, "0");
	} catch(e) {
		console.error(e);
	}
	// add 9x9 grid
	for (let i=0; i<9; i++) {
		const row = document.createElement("tr");
		for (let j=0; j<9; j++) {
			const cell = document.createElement("td");
			const input = document.createElement("input");
			const value = sudoku.code_decimal[9 * i + j];
			input.type = "text";
			input.className = "sudoku";
			input.pattern = "[0-9]*";
			input.inputmode = "numeric";
			input.maxLength = 1;
			input.id = String(i) + String(j);
			input.value = (value === "0") ? "" : value;
			input.addEventListener("keydown", validateKeyDown);
			input.addEventListener("input", moveNextCell);
			cell.appendChild(input);
			row.appendChild(cell);
		}
		table.appendChild(row);
	}
	// add event listeners
	document.getElementById("left-button").addEventListener("click", leftButton);
	document.getElementById("right-button").addEventListener("click", rightButton);
	document.getElementById("next").addEventListener("click", nextStep);
	document.getElementById("skip").addEventListener("click", skipToEnd);
	document.getElementById("speed-down").addEventListener("click", speedDown);
	document.getElementById("speed-up").addEventListener("click", speedUp);
	document.getElementById("speed").addEventListener("change", changeSpeed);
}

/**
 * @function
 * function called when user presses a button in a sudoku cell. Either user inputs a number (1-9), or
 * presses a key to move focused input. 0 can be input to skip a cell (see moveNextCell)
 * @param {KeyboardEvent} event - KeyboardEvent
 */
function validateKeyDown(event) {
	const selected = event.target.id;
	if (/[1-9]/.test(event.key)) {
		// type normally
		return;
	}
	// other key inputs
	switch (event.key) {
		case "Backspace":
		case "Delete":
		case "Tab":
			break;
		case "0":
		case "ArrowRight":
			moveNextCell(event);
			event.preventDefault();
			break;
		case "ArrowUp":
			if (selected[0] !== "0") {
				document.getElementById(String(Number(selected[0]) - 1) + selected[1]).select();
			}
			event.preventDefault();
			break;
		case "Enter":
		case "ArrowDown":
			if (selected[0] !== "8") {
				document.getElementById(String(Number(selected[0]) + 1) + selected[1]).select();
			}
			event.preventDefault();
			break;
		case "ArrowLeft":
			if (selected[1] !== "0") {
				document.getElementById(selected[0] + String(Number(selected[1]) - 1)).select();
			}
			event.preventDefault();
			break;
		default:
			// prevent this key from being input
			event.preventDefault();
	}
}

/**
 * @function
 * function called when user changes the value in an sudoku cell. If user inputs a number, move to
 * next cell in the grid. 0 can be input to skip a cell (see validateKeyDown)
 * @param {Event} event - event
 */
function moveNextCell(event) {
	const regex = /ArrowRight|\d/;
	const selected = event.target.id;
	if (regex.test(event.data) || regex.test(event.key)) {
		if (selected[1] === "8") {
			if (selected[0] !== "8") {
				document.getElementById(String(Number(selected[0]) + 1) + "0").select();
			}
		} else {
			document.getElementById(selected[0] + String(Number(selected[1]) + 1)).select();
		}
	}
}

/**
 * @function
 * function to call when "generate a puzzle for me" is pressed. Inputs a pregenerated sudoku into
 * the grid, allowing the user to view the algorithm without manually inputting one themselves.
 */
function randomiseSudoku() {
	if (sudoku.bruteforcer) {
		return;
	}
	let pregen = sudoku.pregen[Math.floor(sudoku.pregen.length * Math.random())];
	for (let i=0; i<9; i++) {
		for (let j=0; j<9; j++) {
			let cell = pregen[9 * i + j];
			document.getElementById(String(i) + String(j)).value = (cell === "0") ? "" : cell;
		}
	}
}

/**
 * @function
 * function to call when the left button, "Reset" or "Clear", is pressed.
 */
function leftButton() {
	if (document.getElementById("left-button").innerText === "Clear") {
		sudoku.clear();
	} else {
		sudoku.reset();
	}
}

/**
 * @function
 * function to call when the rightmost button, "Start" or "Pause", is pressed.
 */
function rightButton() {
	// sudoku in progress
	if (sudoku.bruteforcer) {
		if (document.getElementById("right-button").innerText === "Resume") {
			sudoku.play();
		} else {
			sudoku.pause();
		}
		return;
	}
	// starting a new sudoku
	sudoku.start();
}

/**
 * @function
 * function to call when "Speed Down" is pressed.
 */
function speedDown() {
	const current_speed = Number(document.getElementById("speed").value);
	const new_speed = Math.max(1, 0.5 * current_speed);
	document.getElementById("speed").value = String(new_speed);
	sudoku.speed = new_speed;
	if (sudoku.bruteforcer && sudoku.timer) {
		sudoku.play();
	}
}

/**
 * @function
 * function to call when "Speed Up" is pressed.
 */
function speedUp() {
	const current_speed = Number(document.getElementById("speed").value);
	const new_speed = Math.min(2 * current_speed, 1e6);
	document.getElementById("speed").value = String(new_speed);
	sudoku.speed = new_speed;
	if (sudoku.bruteforcer && sudoku.timer) {
		sudoku.play();
	}
}

/**
 * @function
 * function called when user changes the speed of the algorithm. caps speed between 1 and 1000000.
 * @param {Event} event - Event
 */
function changeSpeed(event) {
	const new_speed = Math.max(1, Math.min(event.target.value, 1e6));
	event.target.value = String(new_speed);
	sudoku.speed = new_speed;
	if (sudoku.bruteforcer && sudoku.timer) {
		sudoku.play();
	}
}

/**
 * @function
 * function to call when "Next step" is pressed.
 */
function nextStep() {
	sudoku.next(1);
}

/**
 * @function
 * function to call when "Skip to end" is pressed.
 */
function skipToEnd() {
	sudoku.next(1e9);
}

window.onload = setUp;
